Използвайте собствени реализации за всички структури, които използвате във вашите проекти. Всички структури трябва да се грижат правилно за паметта и да позволяват да бъдат копирани. За задачите с вход/изход от/във файлове сами изберете подходящо представяне.

На защитата ще трябва за всяка от използваните структури да можете да обясните как е организирана, как работи, как се реализират различните операции чрез нея и как я използвате.

__Проект 1 (50 т.)__ Нека имаме израз над целите числа със следните оператори и съответни операции:

*   +, -, \*, / и % (бинарни; ляво-асоциативни) — обичайните аритемтични операции, като делението е целочислено;
*   +, - (унарни) — идентитет и отрицание, например +4, -3;
*   ^ (бинарен, дясно-асоциативен) — повдигане на степен;
*   &lt;, &lt;=, =, != , &gt;= и &gt; (бинарни, ляво-асоциативни) — релационните оператори. Връщат истина като 1 и лъжа като 0;
*   ! (унарен), ^, & и | (бинарни, ляво-асоциативни) — логическите операции. Всяко число, различно от 0, приемат за истина, а 0 — за лъжа. Аналогичо връщат истина като 1 и лъжа като 0;
*   -&gt;, &lt;-&gt; и -&gt; (бинарни) — импликация (ляво-асоциативен), (булева) еквивалентност (ляво-асоциативен) и обратна импликация (дясно-асоциативен). Държат се с числата аналогично на предишните две групи оператори. Забележете, че 4 &lt;-&gt; 3 е 1.

Операторите се нареждат в намаляващ приоритет по следния начин:

1.   !;
2.   **;
3.   + и - (унарни);
3.   \*, / и %;
4.   + и - (бинарни);
5.   &lt;, &lt;=, &gt;= и &gt;;
6.   = и !=;
7.   &;
8.   |;
9.   -&gt;, &lt;-&gt; и -&gt;.

Освен това в езика на изразите присъстват и скоби, като действията в тях са с най-висок приоритет.

Напишете програма, която по въведен израз от горния вид проверява дали той е валиден и изчислява стойността му.

__(+20 т.)__ Разширете вашата програма, така че да позволява дефинирането на функции. Всяка функция си има име — низ, започващ с главна буква, и израз от горния вид, в който допълнително добавяме променливи — последователност от символи (низ), започваща с малка буква. За да се изчисли функцията трябва да ѝ бъдат подадени толкова на брой аргументи, колкото са различните променливи в нея, и всяка от променливите да се замести със съответния ѝ аргумент. За да се определи на кой аргумент съответства дадена променлива, сортираме имената на всички променливи в израза лексикографски. Първата променлива от тази наредба съответства на първия аргумент, втората на втория и т. н. Например за израза `y*z+x*y` и аргументи 2, 3 и 4 след заместване получаваме израза 3*4+2*3.

Допълнително дефинираме като израз последователността `ИмеНаФункция(израз1,израз2,...,изразn)`, където ИмеНаФункция е име на дефинирана функция с n аргумента, а израз1, ..., изразn са валидни изрази. Нейната стойност е стойността на израза на съответната функция с аргументи стойностите на израз1, ..., изразn.

Нека вашата програма да позволява дефиниране на функции и изчисляване на изрази в интерактивен режим.

__Проект 2 (65 т.)__ В този проект ще имплементираме проста стекова машина.

Типовете данни в нашата машина са два вида — int и указател към int. Точния тип зависи от инструкцията, поради което двата могат да бъдат обединени в следния тип:

    union DataType {
	    int intValue;
		int* ptrValue;
	};

Машината се състои от следното:

*   Масив от инструкции — програма, която бива изпълнявана от машината;
*   Регистър PC — указва текущо изпълняваната от машината инструкция. В началото изпълнението започва от първата инструкция от масива (PC е 0);
*   4 регистъра за общо предназначение — съхраняват данни от един от двата типа;
*   Data Stack — стек с данни. Почти всички инструкции работят с данните на върха му;
*   Call Stack — стек, съхраняващ адреса за връщане от текущо-изпълняваната функция и състоянието на регистрите за общо-ползване преди нейното извикване;

Машината трябва да поддържа следните инструкции:

| Инструкция                      | Връх на Data Stack преди -&gt; след | Описание                                                                                        |
| ------------------------------- | ---------------------------- | ----------------------------------------------------------------------------------------------- |
| push &lt;число&gt;                    | -&gt; &lt;число&gt;                   | Добавя числото на върха на стека                                                                |
| load1, load2, load3, load4      | -&gt; V                         | V е стойността, съхранявана в съответния общ регистър (1, 2, 3 или 4)                           |
| store1, store2, store3, store4  | V -&gt;                         | Записва в съответния общ регистър стойността V                                                  |
| alloc                           | N -&gt; P                       | Заделя масив от N елемента в паметта и записва указател към първия му елемент на върха на стека |
| free                            | P -&gt;                         | Освобождава паметта, сочена от P                                                                |
| load                            | P -&gt; V(P)                    | Добавя на върха на стека стойнността, сочена от P                                               |
| store                           | P V -&gt;                       | Записва в обекта, сочен от P, стойността V                                                      |
| dup                             | V -&gt; V V                     | Дуплицира върха на стека                                                                        |
| add                             | A B -&gt; &lt;A + B&gt;               | Събира двете числа на върха на стека (те се премахват от него, а на върха остава сборът им)     |
| sub                             | A B -&gt; &lt;A - B&gt;               | Разлика                                                                                         |
| mult                            | A B -&gt; &lt;A * B&gt;               | Умножение                                                                                       |
| div                             | A B -&gt; &lt;A / B&gt;               | Целочислено деление                                                                             |
| padd                            | P B -&gt; &lt;P + B&gt;               | Генерира указател към B на брой елемента след елемента, сочен от P                              |
| psub                            | P B -&gt; &lt;P - B&gt;               | Генерира указател към B на брой елемента преди елемента, сочен от P                             |
| cmp                             | A B -&gt; C                     | C е стойност &lt; 0, ако A &lt; B, = 0, ако A == B и &gt; 0 иначе                                        |
| gotoiflt                        | C I -&gt;                       | Ако C е по-малко от 0 отиди на инструкция I (промени PC на I)                                   |
| gotoifeq                        | C I -&gt;                       | Ако C е равно на 0 отиди на инструкция I                                                        |
| goto                            | I -&gt;                         | Отиди на инструкция I                                                                           |
| call                            | I -&gt;                         | Добавя следващата инструкция към Call Stack-а. Добавя 4-те общи регистъра към Call Stack-а. Изпълнението на програмата продължава от инструкция I (извикване на функция) |
| ret                             | -&gt;                           | Връща състоянието на 4-те регистъра (като ги pop-а от Call Stack-а). Изпълнението продължава от инструкцията на върха на Call Stack (pop—вайки и нея) (връщане от функция) |
| geti                            | -&gt; V                         | Прочита от стандартния вход цяло число V                                                        |
| print                           | V -&gt;                         | Записва на стандартния изход числото В, последвано от нов ред                                   |

Всяка от инструкциите е 8-байтова. Първите 4 байта са избран от вас номер на инструкцията, а последните 4 — аргумент на инструкцията (при всички инструкции, освен push, той се игнорира; типът му е DataType).

Програма на асемблерния език на тази машина е текстов файл, състоящ се от последователност от редове, съдържащи по една от горните инструкции. Празните редове се игнорират. Допълнително за улеснение се допуска следния синтаксис:

*   `етикет:` на самостоятелен ред — асоциира следващата инструкция с този етикет (дава ѝ това име);
*   `gotoiflt етикет` — разширява се до инструкциите push &lt;номера инструкцията, съответваща на етикета&gt; и gotoiflt;
*   `gotoifeq етикет` — разширява се до инструкциите push &lt;номера инструкцията, съответваща на етикета&gt; и gotoifeq;
*   `goto етикет` — разширява се до инструкциите push &lt;номера инструкцията, съответваща на етикета&gt; и goto;
*   `fn етикет` на самостоятелен ред — асоциира следващата инструкция като начало на функция с име този етикет;
*   `call етикет` — разширява се до инструкциите push &lt;номера инструкцията, съответваща на етикета&gt; и call;

Въвеждане на масив на този език би изглеждало така:

	goto main
	
	fn read-array
	geti // брой елементи на масива
	store1 // съхраняваме го в първия регистър
	
	load1
	alloc
	store2 // съхраняваме във втория регистър указател към масив от въведения брой елементи
	
	push 0
	store3 // инициализира брояча на позиция в масива
	
	read-array-loop:
	load3
	load1
	cmp
	gotoifeq end-read-array // ако сме достигнали броя на елементите, то край
	
	load2
	load3
	padd
	geti
	store // записва въведеното число на съответната позиция от масива
	
	load3
	push 1
	add
	store3 // увеличаваме брояча с 1
	
	goto read-array-loop // преминаваме към следващата итерация за въвеждане
	
	end-read-array:
	load2 // връщаме указател към масива
	load3 // връщаме броя на елементите му
	ret
	
	main:
	call read-array

Вашата задача е да напишете програма, която прочита текстов файл с асемблер, компилира го до масив от инструкции и го изпълнява.

__(+35 т.)__ Напишете програма на горния език, която сортира въведен от потребителя масив по избран от вас алгоритъм и го извежда на екрана. Ако е необходимо, може да приемете, че машината има повече регистри за общо предназначение.

__Проект 3 (45 т.)__ Реализирайте алгоритъма на Дийкстра чрез двоична пирамида.

__(+15 т.)__ Разширете вашата реализация и решете следната задача:

Дадени са N града, като между градовете има автобусни връзки. За даден град i на всеки Ki часа тръгват автобуси за всички автобусни връзки от този град. Ако човек пристигне по-рано то трябва да изчака необходимия брой часове. Първоначално всички автобуси тръгват във време 0. Във файл в подходящ формат е описана цялата информация за автобусната мрежа. Градовете се представят като число между 0 и N - 1. Във файла за всяка автобусна връзка е описана от кой до кой град е и каква е неговата продължителност в брой часове. Също така за всеки град е посочено през колко време тръгват автобусите. Напишете програма, която намира най-краткия по време път между два града (градовете също са посочени във файла) и изведете самия път от началния до крайния град и колко време ще отнеме той. 

__Проект 4 (50 т.)__ Disjoint-set е специална структура, която позволява реализирането на абстракция за крайни непресичащи се множества с няколко бързи операции. Такива операции са обединение на две множества и проверка даден елемент на кое множество принадлежи. Потърсете информация за какво представлява структурата и реализирайте ваша добре оптимизирана версия (нека да използва поне компресия на пътя и обединение по ранг).

След това реализирайте алгоритъма на Крускал за намиране на минимално покриващо дърво на граф, използвайки така написаната структура. Напишете програма, която прочита граф от файл във подходящ формат и във друг файл записва намереното минимално покриващо дърво. Ако графът не е свързан нека да извежда съобщение за това.

__Проект 5 (60 т.)__ Код на Хъфмън е алгоритъм за компресиране на последователност от символи. Той се представя чрез двоично дърво, за което:

*   всяко от листата на дървото е асоциирано с определен символ и има тегло, съответващо на вероятността този символ да се среща;
*   всеки други възел има точно две деца. С него е асициирано множеството от символи, което се получава от обединението на множеството от символи на децата му, а теглото му е сборът от теглата на децата му.

Примерно дърво на Хъфман е:

![Huffman tree](images/huffman.png?raw=true)

Дървото на Хъфман може да се използва за кодиране и декодиране.

Кодирането превръща последователността от символи в последователност от битове. За всеки символ от низа обхождаме дървото от корена докато не достигнем листото, с което е асоцииран символа, като се движим по възлите, съдържащи символа. При всяко разклонение, ако тръгнем по ляво поддърво добавяме 0 към изходната последователност, а по дясно — 1. Например за дървото горе последователността FCA се кодира като 110110100.

Декодирането е аналогично. Започваме от корена на дървото докато не стигнем листо, като при всяко разклонение избираме поддървото съответващо на текущия бит. При достигане на листо добавяме неговия символ към изходната последователност и се връщаме отново на листото.

Оптимално дърво на Хъфман за дадена последователност може да се построи по следния алгоритъм:

1. Изчислете броя на срещанията на всеки символ в последователността;
2. За всеки символ създайте листо с тегло броя на срещания на символа;
3. Създайте списък, който съдържа листата, сортирани по тяхното тегло.
4. Докато в списъка не остане едно единствено дърво, вземете първите две дървета от символа, създайте възел — техен родител, и добавете дървото в списъка на мястото, съответващо на неговото теглото.
5. Единственото дърво в списъка е оптималното дърво на Хъфман за последователността от символи.

Напишете програма encode, която по подаден път на файл строи оптимално дърво на Хъфман, кодира файла и създава двоичен файл (пътят до който също се подава), който съдържа подходящо представяне на дървото на Хъфман (такова, от което то може да бъде построено) и кодираната последователност от битове.

Напишете програма decode, която по подаден път на файл, генериран от предната програма, построява дървото на Хъфман и декодира последователността от битове, като резултата записва в друг файл (пътят до който също е подаден).

(За реализация на проекта бихте могли да използвате подходяща структура за масив от битове.)

__Проект 6 (85 т.)__ Реализирайте абстрактен тип речник (map) с операции асоцииране на ключ с определена стойност (put), премахване на ключ (remove), проверка за съдържание на ключ (contains) и проверка за съдържание на стойност (containsValue), използвайки структурата от данни AA дърво. Имплементирайте in-order итератор по речника. Напишете тестове на реализацията, които

*   тестват операциите (put, remove, contains, containsValue, итерация);
*   проверяват, че дървото е Binary-Search Tree;
*   проверяват балансираността на дървото;
*   проверяват всички инварианти на съответното структура.

__Проект 7 (90 т.)__ Реализирайте абстрактен тип множество с операции вмъкване на елемент, премахване на елемент и проверка за съдържание на елемент, използвайки структурата от данни червено-черно дърво. Имплементирайте in-order итератор по множеството. Напишете тестове на реализацията, които 

*   тестват операциите (insert, remove, contains, итерация);
*   проверяват, че дървото е Binary-Search Tree;
*   проверяват балансираността на дървото;
*   проверяват всички инварианти на съответното структура.
